# 垃圾回收及内存泄漏

## 垃圾回收

- 执行环境负责在代码执行时管理内存。
- JavaScript为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。
- 垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定”的问题，意味着靠算法是解决不了的。

**垃圾回收基本思路:**

确定哪个变量不会再使用，然后释放它占用的内存。

**触发时机:**

周期性，即垃圾回收程序每隔一定时间就会自动运行。

**垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。标记未使用的变量:**

## 回收方案1 - 标记清理

JavaScript最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。
而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。
当变量离开上下文时，也会被加上离开上下文的标记。

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。
标记过程的实现并不重要，关键是策略。

:::info 垃圾回收逻辑

1. 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。
2. 将所有在上下文中的变量，变量引用的其他变量的标记去掉。
3. 在此之后依然存在标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。
4. 随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

:::

## 回收方案2 - 引用计数（有缺陷）

1. 对每个值都记录它被引用的次数。
2. 声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。
3. 类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。
4. 当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。
5. 垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。

:::danger 循环引用

循环引用时引用计数无法清0，导致无法释放内存。

```js title=
function problem() {
  let objectA = new Object();
  let objectB = new Object();
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```
:::

## 内存泄漏

1. 意外声明全局变量

```js title=
function setName() {
  name = 'Jake';
}
```

2. 定时器

```js title=
let name = 'Jake';
setInterval(() => {
  console.log(name);
}, 100);
```

3. 闭包

闭包使用不当会造成内存泄漏。

```js title=
let outer = function() {
  let name = 'Jake';
  // str 实际没用到，但依然占据内存。
  const str = 'asdf'.repeat(10000000)
  return function() {
    return name;
  };
};
```

用例:

![20240110153838](https://blog-1318409910.cos.ap-beijing.myqcloud.com/blog/20240110153838.png)

[`内存泄漏`](https://s3.amazonaws.com/chromebugs/memory.html)

[`知乎回答`](https://www.zhihu.com/question/31078912)

调用outer()会导致分配给name的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用着它。
假如name的内容很大（不止是一个小字符串），那可能就是个大问题了。

## 减少浏览器执行垃圾回收的次数

开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。
理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。

频繁创建对象并销毁对象，则浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。

```js title=
function addVector(a, b) {
  let resultant = new Vector();
  resultant.x = a.x + b.x;
  resultant.y = a.y + b.y;
  return resultant;
}
```

如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。
假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。

解决方案：

不要动态创建矢量对象，而是使用固定大小的对象池，复用之前的对象。

```js title=
function addVector(a, b, resultant) {
  resultant.x = a.x + b.x;
  resultant.y = a.y + b.y;
  return resultant;
}
```
